{
  "topics": {
    "data": {
      "0": {
        "name": "0_problem_time_algorithm_set",
        "keywords": [
          [
            "problem",
            0.03408390319908812
          ],
          [
            "time",
            0.030948007316606334
          ],
          [
            "algorithm",
            0.028545617134190564
          ],
          [
            "set",
            0.026026549601842065
          ],
          [
            "points",
            0.025551505878814575
          ],
          [
            "graph",
            0.02202197211527162
          ],
          [
            "number",
            0.021405793819355756
          ],
          [
            "graphs",
            0.019007890384922933
          ],
          [
            "point",
            0.01808068731306621
          ],
          [
            "plane",
            0.01525473911120673
          ]
        ],
        "count": 2141
      },
      "1": {
        "name": "1_mesh_3D_method_surface",
        "keywords": [
          [
            "mesh",
            0.03243748957574397
          ],
          [
            "3D",
            0.03152684124123342
          ],
          [
            "method",
            0.030423848933107865
          ],
          [
            "surface",
            0.028214297886095287
          ],
          [
            "shape",
            0.022847345234027643
          ],
          [
            "meshes",
            0.02131028411732643
          ],
          [
            "surfaces",
            0.020564631366344892
          ],
          [
            "methods",
            0.020563433203738664
          ],
          [
            "point",
            0.017862125840343728
          ],
          [
            "approach",
            0.015942083006677488
          ]
        ],
        "count": 394
      },
      "2": {
        "name": "2_persistence_homology_persistent_data",
        "keywords": [
          [
            "persistence",
            0.04620775276964165
          ],
          [
            "homology",
            0.04118619686769749
          ],
          [
            "persistent",
            0.03620653090379677
          ],
          [
            "data",
            0.032731324042685854
          ],
          [
            "topological",
            0.031074116502931057
          ],
          [
            "persistent homology",
            0.028982975321549413
          ],
          [
            "complex",
            0.01878785580252437
          ],
          [
            "complexes",
            0.017283794457279074
          ],
          [
            "filtration",
            0.01724453915004864
          ],
          [
            "simplicial",
            0.016687422793692022
          ]
        ],
        "count": 350
      },
      "3": {
        "name": "3_merge_trees_scalar_merge trees",
        "keywords": [
          [
            "merge",
            0.05966298187502568
          ],
          [
            "trees",
            0.05851146773611255
          ],
          [
            "scalar",
            0.05060404118794107
          ],
          [
            "merge trees",
            0.04987669683956241
          ],
          [
            "topological",
            0.04073828473955507
          ],
          [
            "data",
            0.03851249075991889
          ],
          [
            "fields",
            0.038013309705786404
          ],
          [
            "scalar fields",
            0.03319357179579252
          ],
          [
            "Reeb",
            0.03197760241771714
          ],
          [
            "distance",
            0.030199246576706182
          ]
        ],
        "count": 58
      }
    },
    "correlations": [
      [
        1.0,
        -0.5734931147330437,
        -0.4458569784115325,
        -0.666953196759039
      ],
      [
        -0.5734931147330437,
        1.0,
        -0.6400812146160552,
        -0.7145962704967662
      ],
      [
        -0.4458569784115325,
        -0.6400812146160552,
        1.0,
        -0.42243696666570013
      ],
      [
        -0.666953196759039,
        -0.7145962704967662,
        -0.42243696666570013,
        1.0
      ]
    ],
    "series": {
      "2020-01": [
        28,
        5,
        5,
        2
      ],
      "2020-02": [
        50,
        2,
        5,
        3
      ],
      "2020-03": [
        57,
        7,
        4,
        1
      ],
      "2020-04": [
        50,
        5,
        6,
        1
      ],
      "2020-05": [
        33,
        5,
        4,
        2
      ],
      "2020-06": [
        43,
        3,
        3,
        0
      ],
      "2020-07": [
        64,
        11,
        2,
        5
      ],
      "2020-08": [
        34,
        6,
        1,
        3
      ],
      "2020-09": [
        26,
        7,
        5,
        0
      ],
      "2020-10": [
        33,
        4,
        8,
        1
      ],
      "2020-11": [
        41,
        5,
        6,
        1
      ],
      "2020-12": [
        41,
        10,
        7,
        2
      ],
      "2021-01": [
        26,
        5,
        4,
        4
      ],
      "2021-02": [
        27,
        4,
        4,
        0
      ],
      "2021-03": [
        59,
        14,
        5,
        0
      ],
      "2021-04": [
        32,
        2,
        5,
        0
      ],
      "2021-05": [
        30,
        7,
        8,
        1
      ],
      "2021-06": [
        51,
        4,
        5,
        3
      ],
      "2021-07": [
        38,
        2,
        8,
        3
      ],
      "2021-08": [
        38,
        3,
        4,
        4
      ],
      "2021-09": [
        39,
        2,
        5,
        1
      ],
      "2021-10": [
        32,
        5,
        6,
        2
      ],
      "2021-11": [
        45,
        10,
        5,
        1
      ],
      "2021-12": [
        40,
        3,
        9,
        3
      ],
      "2022-01": [
        25,
        8,
        7,
        1
      ],
      "2022-02": [
        37,
        2,
        3,
        1
      ],
      "2022-03": [
        43,
        3,
        6,
        3
      ],
      "2022-04": [
        20,
        3,
        6,
        1
      ],
      "2022-05": [
        24,
        10,
        8,
        0
      ],
      "2022-06": [
        39,
        5,
        7,
        2
      ],
      "2022-07": [
        35,
        7,
        6,
        3
      ],
      "2022-08": [
        33,
        3,
        6,
        2
      ],
      "2022-09": [
        41,
        2,
        3,
        0
      ],
      "2022-10": [
        23,
        2,
        7,
        2
      ],
      "2022-11": [
        33,
        1,
        5,
        0
      ],
      "2022-12": [
        19,
        6,
        12,
        3
      ],
      "2023-01": [
        24,
        4,
        5,
        2
      ],
      "2023-02": [
        29,
        2,
        4,
        1
      ],
      "2023-03": [
        55,
        6,
        10,
        4
      ],
      "2023-04": [
        20,
        4,
        6,
        0
      ],
      "2023-05": [
        38,
        6,
        2,
        2
      ],
      "2023-06": [
        40,
        3,
        8,
        3
      ],
      "2023-07": [
        31,
        4,
        2,
        2
      ],
      "2023-08": [
        35,
        4,
        4,
        7
      ],
      "2023-09": [
        31,
        3,
        2,
        4
      ],
      "2023-10": [
        36,
        12,
        2,
        4
      ],
      "2023-11": [
        29,
        1,
        3,
        3
      ],
      "2023-12": [
        34,
        4,
        8,
        1
      ],
      "2024-01": [
        34,
        6,
        2,
        3
      ],
      "2024-02": [
        55,
        7,
        6,
        4
      ],
      "2024-03": [
        43,
        2,
        6,
        6
      ],
      "2024-04": [
        33,
        7,
        4,
        5
      ],
      "2024-05": [
        22,
        9,
        6,
        1
      ],
      "2024-06": [
        32,
        0,
        7,
        3
      ],
      "2024-07": [
        39,
        4,
        1,
        3
      ],
      "2024-08": [
        20,
        3,
        3,
        6
      ],
      "2024-09": [
        37,
        4,
        5,
        3
      ],
      "2024-10": [
        44,
        8,
        6,
        2
      ],
      "2024-11": [
        32,
        3,
        6,
        0
      ],
      "2024-12": [
        40,
        3,
        10,
        2
      ],
      "2025-01": [
        24,
        5,
        4,
        3
      ],
      "2025-02": [
        29,
        4,
        6,
        1
      ],
      "2025-03": [
        40,
        7,
        4,
        2
      ],
      "2025-04": [
        49,
        4,
        5,
        3
      ],
      "2025-05": [
        28,
        4,
        4,
        4
      ],
      "2025-06": [
        50,
        7,
        5,
        1
      ],
      "2025-07": [
        38,
        7,
        4,
        3
      ],
      "2025-08": [
        46,
        4,
        6,
        9
      ],
      "2025-09": [
        19,
        2,
        1,
        1
      ]
    },
    "papers": {
      "0": [
        {
          "title": "Unweighted Geometric Hitting Set for Line-Constrained Disks and Related Problems",
          "year": "2024-06",
          "abstract": "Given a set $P$ of $n$ points and a set $S$ of $m$ disks in the plane, the\ndisk hitting set problem asks for a smallest subset of $P$ such that every disk\nof $S$ contains at least one point in the subset. The problem is NP-hard. In\nthis paper, we consider a line-constrained version in which all disks have\ntheir centers on a line. We present an $O(m\\log^2n+(n+m)\\log(n+m))$ time\nalgorithm for the problem. This improves the previously best result of\n$O(m^2\\log m+(n+m)\\log(n+m))$ time for the weighted case of the problem where\nevery point of $P$ has a weight and the objective is to minimize the total\nweight of the hitting set. Our algorithm actually solves a more general\nline-separable problem with a single intersection property: The points of $P$\nand the disk centers are separated by a line $\\ell$ and the boundary of every\ntwo disks intersect at most once on the side of $\\ell$ containing $P$.",
          "arxiv_id": "2407.00331v1"
        },
        {
          "title": "An Optimal Algorithm for Shortest Paths in Unweighted Disk Graphs",
          "year": "2025-07",
          "abstract": "Given in the plane a set $S$ of $n$ points and a set of disks centered at\nthese points, the disk graph $G(S)$ induced by these disks has vertex set $S$\nand an edge between two vertices if their disks intersect. Note that the disks\nmay have different radii. We consider the problem of computing shortest paths\nfrom a source point $s\\in S$ to all vertices in $G(S)$ where the length of a\npath in $G(S)$ is defined as the number of edges in the path. The previously\nbest algorithm solves the problem in $O(n\\log^2 n)$ time. A lower bound of\n$\\Omega(n\\log n)$ is also known for this problem under the algebraic decision\ntree model. In this paper, we present an $O(n\\log n)$ time algorithm, which\nmatches the lower bound and thus is optimal. Another virtue of our algorithm is\nthat it is quite simple.",
          "arxiv_id": "2507.05569v1"
        },
        {
          "title": "A polynomial-time $\\text{OPT}^Îµ$-approximation algorithm for maximum independent set of connected subgraphs in a planar graph",
          "year": "2023-10",
          "abstract": "In the Maximum Independent Set of Objects problem, we are given an $n$-vertex\nplanar graph $G$ and a family $\\mathcal{D}$ of $N$ objects, where each object\nis a connected subgraph of $G$. The task is to find a subfamily $\\mathcal{F}\n\\subseteq \\mathcal{D}$ of maximum cardinality that consists of pairwise\ndisjoint objects. This problem is $\\mathsf{NP}$-hard and is equivalent to the\nproblem of finding the maximum number of pairwise disjoint polygons in a given\nfamily of polygons in the plane.\n  As shown by Adamaszek et al. (J. ACM '19), the problem admits a\n\\emph{quasi-polynomial time approximation scheme} (QPTAS): a\n$(1-\\varepsilon)$-approximation algorithm whose running time is bounded by\n$2^{\\mathrm{poly}(\\log(N),1/\\epsilon)} \\cdot n^{\\mathcal{O}(1)}$. Nevertheless,\nto the best of our knowledge, in the polynomial-time regime only the trivial\n$\\mathcal{O}(N)$-approximation is known for the problem in full generality. In\nthe restricted setting where the objects are pseudolines in the plane, Fox and\nPach (SODA '11) gave an $N^{\\varepsilon}$-approximation algorithm with running\ntime $N^{2^{\\tilde{\\mathcal{O}}(1/\\varepsilon)}}$, for any $\\varepsilon>0$.\n  In this work, we present an $\\text{OPT}^{\\varepsilon}$-approximation\nalgorithm for the problem that runs in time\n$N^{\\tilde{\\mathcal{O}}(1/\\varepsilon^2)} n^{\\mathcal{O}(1)}$, for any\n$\\varepsilon>0$, thus improving upon the result of Fox and Pach both in terms\nof generality and in terms of the running time. Our approach combines the\nmethodology of Voronoi separators, introduced by Marx and Pilipczuk (TALG '22),\nwith a new analysis of the approximation factor.",
          "arxiv_id": "2310.20325v1"
        }
      ],
      "1": [
        {
          "title": "MeshWalker: Deep Mesh Understanding by Random Walks",
          "year": "2020-06",
          "abstract": "Most attempts to represent 3D shapes for deep learning have focused on\nvolumetric grids, multi-view images and point clouds. In this paper we look at\nthe most popular representation of 3D shapes in computer graphics - a\ntriangular mesh - and ask how it can be utilized within deep learning. The few\nattempts to answer this question propose to adapt convolutions & pooling to\nsuit Convolutional Neural Networks (CNNs). This paper proposes a very different\napproach, termed MeshWalker, to learn the shape directly from a given mesh. The\nkey idea is to represent the mesh by random walks along the surface, which\n\"explore\" the mesh's geometry and topology. Each walk is organized as a list of\nvertices, which in some manner imposes regularity on the mesh. The walk is fed\ninto a Recurrent Neural Network (RNN) that \"remembers\" the history of the walk.\nWe show that our approach achieves state-of-the-art results for two fundamental\nshape analysis tasks: shape classification and semantic segmentation.\nFurthermore, even a very small number of examples suffices for learning. This\nis highly important, since large datasets of meshes are difficult to acquire.",
          "arxiv_id": "2006.05353v3"
        },
        {
          "title": "FoR$^2$M: Recognition and Repair of Foldings in Mesh Surfaces. Application to 3D Object Degradation",
          "year": "2022-06",
          "abstract": "Triangular meshes are the most popular representations of 3D objects, but\nmany mesh surfaces contain topological singularities that represent a challenge\nfor displaying or further processing them properly. One such singularity is the\nself-intersections that may be present in mesh surfaces that have been created\nby a scanning procedure or by a deformation transformation, such as\noff-setting.\n  Mesh foldings comprise a special case of mesh surface self-intersections,\nwhere the faces of the 3D model intersect and become reversed, with respect to\nthe unfolded part of the mesh surface. A novel method for the recognition and\nrepair of mesh surface foldings is presented, which exploits the structural\ncharacteristics of the foldings in order to efficiently detect the folded\nregions. Following detection, the foldings are removed and any gaps so created\nare filled based on the geometry of the 3D model. The proposed method is\ndirectly applicable to simple mesh surface representations while it does not\nperform any embedding of the 3D mesh (i.e. voxelization, projection). Target of\nthe proposed method is to facilitate mesh degradation procedures in a fashion\nthat retains the original structure, given the operator, in the most efficient\nmanner.",
          "arxiv_id": "2206.09699v1"
        },
        {
          "title": "Filling the Holes on 3D Heritage Object Surface based on Automatic Segmentation Algorithm",
          "year": "2023-10",
          "abstract": "Reconstructing and processing the 3D objects are popular activities in the\nresearch field of computer graphics, image processing and computer vision. The\n3D objects are processed based on the methods like geometric modeling, a branch\nof applied mathematics and computational geometry, or the machine learning\nalgorithms based on image processing. The computation of geometrical objects\nincludes processing the curves and surfaces, subdivision, simplification,\nmeshing, holes filling, reconstructing, and refining the 3D surface objects on\nboth point cloud data and triangular mesh. While the machine learning methods\nare developed using deep learning models. With the support of 3D laser scan\ndevices and Lidar techniques, the obtained dataset is close to original shape\nof the real objects. Besides, the photography and its application based on the\nmodern techniques in recent years help us collect data and process the 3D\nmodels more precise. This article proposes an improved method for filling holes\non the 3D object surface based on an automatic segmentation. Instead of filling\nthe hole directly as the existing methods, we now subdivide the hole before\nfilling it. The hole is first determined and segmented automatically based on\ncomputation of its local curvature. It is then filled on each part of the hole\nto match its local curvature shape. The method can work on both 3D point cloud\nsurfaces and triangular mesh surface. Comparing to the state of the art\nmethods, our proposed method obtained higher accuracy of the reconstructed 3D\nobjects.",
          "arxiv_id": "2310.10875v1"
        }
      ],
      "2": [
        {
          "title": "Vietoris-Rips Persistent Homology, Injective Metric Spaces, and The Filling Radius",
          "year": "2020-01",
          "abstract": "In the applied algebraic topology community, the persistent homology induced\nby the Vietoris-Rips simplicial filtration is a standard method for capturing\ntopological information from metric spaces. In this paper, we consider a\ndifferent, more geometric way of generating persistent homology of metric\nspaces which arises by first embedding a given metric space into a larger space\nand then considering thickenings of the original space inside this ambient\nmetric space. In the course of doing this, we construct an appropriate category\nfor studying this notion of persistent homology and show that, in a category\ntheoretic sense, the standard persistent homology of the Vietoris-Rips\nfiltration is isomorphic to our geometric persistent homology provided that the\nambient metric space satisfies a property called injectivity.\n  As an application of this isomorphism result we are able to precisely\ncharacterize the type of intervals that appear in the persistence barcodes of\nthe Vietoris-Rips filtration of any compact metric space and also to give\nsuccinct proofs of the characterization of the persistent homology of products\nand metric gluings of metric spaces. Our results also permit proving several\nbounds on the length of intervals in the Vietoris-Rips barcode by other metric\ninvariants. Finally, as another application, we connect this geometric\npersistent homology to the notion of filling radius of manifolds introduced by\nGromov \\cite{G07} and show some consequences related to (1) the homotopy type\nof the Vietoris-Rips complexes of spheres which follow from work of M.~Katz and\n(2) characterization (rigidity) results for spheres in terms of their\nVietoris-Rips persistence barcodes which follow from work of F.~Wilhelm.",
          "arxiv_id": "2001.07588v8"
        },
        {
          "title": "Cycle Registration in Persistent Homology with Applications in Topological Bootstrap",
          "year": "2021-01",
          "abstract": "In this article we propose a novel approach for comparing the persistent\nhomology representations of two spaces (filtrations). Commonly used methods are\nbased on numerical summaries such as persistence diagrams and persistence\nlandscapes, along with suitable metrics (e.g. Wasserstein). These summaries are\nuseful for computational purposes, but they are merely a marginal of the actual\ntopological information that persistent homology can provide. Instead, our\napproach compares between two topological representations directly in the data\nspace. We do so by defining a correspondence relation between individual\npersistent cycles of two different spaces, and devising a method for computing\nthis correspondence. Our matching of cycles is based on both the persistence\nintervals and the spatial placement of each feature. We demonstrate our new\nframework in the context of topological inference, where we use statistical\nbootstrap methods in order to differentiate between real features and noise in\npoint cloud data.",
          "arxiv_id": "2101.00698v1"
        },
        {
          "title": "MuRiT: Efficient Computation of Pathwise Persistence Barcodes in Multi-Filtered Flag Complexes via Vietoris-Rips Transformations",
          "year": "2022-07",
          "abstract": "Multi-parameter persistent homology naturally arises in applications of\npersistent topology to data that come with extra information depending on\nadditional parameters, like for example time series data. We introduce the\nconcept of a Vietoris-Rips transformation, a method that reduces the\ncomputation of the one-parameter persistent homology of pathwise subcomplexes\nin multi-filtered flag complexes to the computation of the Vietoris-Rips\npersistent homology of certain semimetric spaces. The corresponding pathwise\npersistence barcodes track persistence features of the ambient multi-filtered\ncomplex and can in particular be used to recover the rank invariant in\nmulti-parameter persistent homology. We present MuRiT, a scalable algorithm\nthat computes the pathwise persistence barcodes of multi-filtered flag\ncomplexes by means of Vietoris-Rips transformations. Moreover, we provide an\nefficient software implementation of the MuRiT algorithm which resorts to\nRipser for the actual computation of Vietoris-Rips persistence barcodes. To\ndemonstrate the applicability of MuRiT to real-world datasets, we establish\nMuRiT as part of our CoVtRec pipeline for the surveillance of the convergent\nevolution of the coronavirus SARS-CoV-2 in the current COVID-19 pandemic.",
          "arxiv_id": "2207.03394v1"
        }
      ],
      "3": [
        {
          "title": "Flexible and Probabilistic Topology Tracking with Partial Optimal Transport",
          "year": "2023-02",
          "abstract": "In this paper, we present a flexible and probabilistic framework for tracking\ntopological features in time-varying scalar fields using merge trees and\npartial optimal transport. Merge trees are topological descriptors that record\nthe evolution of connected components in the sublevel sets of scalar fields. We\npresent a new technique for modeling and comparing merge trees using tools from\npartial optimal transport. In particular, we model a merge tree as a measure\nnetwork, that is, a network equipped with a probability distribution, and\ndefine a notion of distance on the space of merge trees inspired by partial\noptimal transport. Such a distance offers a new and flexible perspective for\nencoding intrinsic and extrinsic information in the comparative measures of\nmerge trees. More importantly, it gives rise to a partial matching between\ntopological features in time-varying data, thus enabling flexible topology\ntracking for scientific simulations. Furthermore, such partial matching may be\ninterpreted as probabilistic coupling between features at adjacent time steps,\nwhich gives rise to probabilistic tracking graphs. We derive a stability result\nfor our distance and provide numerous experiments indicating the efficacy of\nour framework in extracting meaningful feature tracks.",
          "arxiv_id": "2302.02895v4"
        },
        {
          "title": "Geometry-Aware Merge Tree Comparisons for Time-Varying Data with Interleaving Distances",
          "year": "2021-07",
          "abstract": "Merge trees, a type of topological descriptor, serve to identify and\nsummarize the topological characteristics associated with scalar fields. They\npresent a great potential for the analysis and visualization of time-varying\ndata. First, they give compressed and topology-preserving representations of\ndata instances. Second, their comparisons provide a basis for studying the\nrelations among data instances, such as their distributions, clusters,\noutliers, and periodicities. A number of comparative measures have been\ndeveloped for merge trees. However, these measures are often computationally\nexpensive since they implicitly consider all possible correspondences between\ncritical points of the merge trees. In this paper, we perform geometry-aware\ncomparisons of merge trees using labeled interleaving distances. The main idea\nis to decouple the computation of a comparative measure into two steps: a\nlabeling step that generates a correspondence between the critical points of\ntwo merge trees, and a comparison step that computes distances between a pair\nof labeled merge trees by encoding them as matrices. We show that our approach\nis general, computationally efficient, and practically useful. Our general\nframework makes it possible to integrate geometric information of the data\ndomain in the labeling process. At the same time, it reduces the computational\ncomplexity since not all possible correspondences have to be considered. We\ndemonstrate via experiments that such geometry-aware merge tree comparisons\nhelp to detect transitions, clusters, and periodicities of time-varying\ndatasets, as well as to diagnose and highlight the topological changes between\nadjacent data instances.",
          "arxiv_id": "2107.14373v1"
        },
        {
          "title": "Edit Distance between Merge Trees",
          "year": "2022-07",
          "abstract": "Topological structures such as the merge tree provide an abstract and\nsuccinct representation of scalar fields. They facilitate effective\nvisualization and interactive exploration of feature-rich data. A merge tree\ncaptures the topology of sub-level and super-level sets in a scalar field.\nEstimating the similarity between merge trees is an important problem with\napplications to feature-directed visualization of time-varying data. We present\nan approach based on tree edit distance to compare merge trees. The comparison\nmeasure satisfies metric properties, it can be computed efficiently, and the\ncost model for the edit operations is both intuitive and captures well-known\nproperties of merge trees. Experimental results on time-varying scalar fields,\n3D cryo electron microscopy data, shape data, and various synthetic datasets\nshow the utility of the edit distance towards a feature-driven analysis of\nscalar fields.",
          "arxiv_id": "2207.08511v1"
        }
      ]
    }
  },
  "metadata": {
    "lastUpdated": "2025-09-24T21:21:17Z",
    "dataVersion": "0.0.2",
    "period": {
      "start": "2020-01",
      "end": "2025-09"
    }
  }
}